\chapter{Discussion}
The result of the study is a protocol for a decentralized cloud computing platform where a free market is used to distribute work throughout the network. In its current state, the protocol is best suited to host web applications, but could easily be extended to more complex types of applications. The protocol itself has no single point of failure, or any external authority which might revoke access to it. However, the workers in the network can still be individually attacked, but it can be argued that workers have the motivation to mitigate such attacks since their payment is dependent on work performance.
The network achieves decentralization because
\begin{inparaenum}[\itshape a\upshape)]
\item the specification and reference implementation are both open source;
\item each end user retains a copy of the blockchain in which the smart contracts and data of the application are stored; and
\item each end user runs the application locally. 
\end{inparaenum}

In the introduction, three basic requirements for the network were listed. The network must be transparent, resilient and trustless. By virtue of the open and distributed data store of blockchain, the network can be deemed to be transparent. Resilience is achieved on the data store level by the Ethereum network, and on the work execution level by incentives offered to workers. The inherent trustlessness in the blockchain and smart contracts allows parties to agree upon work and payment. Thus, we argue that these requirements have been met.

\section{Method discussion}
To alleviate further research in the field, and to allow future studies to build on the conducted thesis work, a brief discussion of caveats shall now be listed.

\subsection{Ethereum client dependencies}
At the inception of the study, three different Ethereum client implementations were widely used: the C++ based client cpp-ethereum; the Go-lang based client go-ethereum; and the Python based client pyethereum. All of the clients were at the time developed in parallel, stepping towards milestones implementing different aspects of the Ethereum specifications. The different clients were not always completely interchangeable, which was cumbersome when trying out new client features on the different platforms. Since the stable releases were rapidly becoming outdated, the implementation was dependent on bleeding edge builds of the C++ and Go clients. As a result of this, lot of time was spent waiting for regression errors to be addressed in certain clients, and for cross-compatibility or workarounds between the two clients to support the development efforts. Thus, the dilemma was to either stay at a stable client version without necessary features - or to stay on the potentially broken bleeding edge. This problem can be completely attributed to the fact that depending on unfinished pre-released software has detrimental effects on the expected productivity.

\subsection{Implementation environment}
The initial solution was to implement the reference implementation in a command line Python client, using HTTP-requests to access the JSON-RPC API provided by Ethereum. This solution was abandoned because the JSON-RPC API expects input on in the form of the Ethereum ABI (Application Binary Interface), which mean that the client would have to supply the binary format. Implementing the ABI would be out of scope and time consuming for the study. Thus, the web3.js library, which implements the Etherereum JavaScript API, acting as a higher level bridge to the Ethereum client. Changing from Python to JavaScript resulted in also changing from a command line client to creating to creating a web application.

\section{Protocol discussion}
Even though the protocol addresses all three problems presented in \fullref{sec:intro:problem} it does so on different abstraction levels for the different subproblems. \fullref{sec:prob:distribution} is the most thought out part of the protocol and is described in an sufficiently detailed way making it easy to implement. \fullref{sec:prob:verification} is described on a more abstract level leaving various implementation details that might be necessary to make verification run reliably to minimize trust. The approach described should however provide a solid ground on which the verification can take place. In \fullref{sec:prob:compensation} the description of the protocol is quite short. However this does not mean that there is any significant information missing. In any sufficiently advanced smart contract system it should be trivial to keep value in a contract and releasing that value to specific users only if certain conditions are met.

\textbf{TODO: WH: Source synthesis discussion}

\section{Reference implementation discussion}
The reference implementation, Zeppelin, does not fulfill the whole protocol specification. One of the main factors that caused this is that the Ethereum platform is still under heavy development. Throughout the study, it has been unreliably to test new features, often with many regression errors and breaking API changes. This made it hard to make any steady progress on a lot of protocol features. Instead, focus was shifted on getting the distribution of work as good as possible.

Since the decentralized technology is emerging, demonstrations and proof of concepts are key tools to achieve user and developer participation. In that sense, the Zeppelin implementation could be bad as an actual technology proof of concept due to the fact that it still requires a regular backend. However, it should still be viewed as a feat, because we show that both can, in fact, interoperate. This can be seen as the greatest virtue of Zeppelin - it is truly a proof of concept.

\subsection{Whisper}
The private chat described in \fullref{sec:res:dependencies} was meant to be fulfilled by Whisper, the peer-to-peer anonymous messaging protocol running in parallel with the Ethereum network. Whisper was to be used in order to exchange information between a client and a worker, such as IP-addresses and ports. Since Whisper only requires a public key and a topic in order to initiate the communication channel. However, the Whisper project has not yet been developed fully as of 13-May-2015. Initial tests using Whisper as private chat gave insufficient performance to be able to function as private chat. This resulted in the decision to work around Whisper, and instead store more information in the smart contracts. Due to this, some of the privacy and security measures mandated by private chat were sacrificed in order to get a working reference implementation.

Security is affected in the following way: in the reference implementation, all IP-addresses and ports are accessible via smart contracts for anyone with access to the blockchain. If an attacker has all IP-addresses for every node (both worker and client), it is trivial to DDoS the nodes in the network. This is particularly dangerous in since, at present, the network is very small. 

\subsection{Networking}
The Internet is a large complicated structure, a network of networks, to negotiate communication between hosts is not always easy. Hosts behind routers need to have one or several ports forwarded to be able to communicate with our network. All of the test units used throughout the course of the project were hosted on a Local Area Network (LAN), under a single private IP-address. This caused problems with Network Address Translation. Two ports are required in order for Zeppelin to work, one for the JSON-RPC and one for the Node web server. The initial solution was to use either UPnP or NAT-PMP for internal port mapping. This would, in theory, solve our problem. 

Unfortunately, due to time constraints and problems during the implementation this feature did not reach a working state. The only way to test UPnP and/or NAT-PMP is via Local Area Network behind a NAT-enabled router. Since all development and testing was conducted remotely from a network with public IP-addresses and no NAT-enabled router, there was no compelling way to ensure this functionality. Instead of continuing on the UPnP solution, we decided on a solution that works well for the environment used during development.
%TODO: bort med we

This solution could be extended to become completely network environment agnostic.

\subsection{Docker and security}
There are two scenarios to consider regarding the security aspects relating to Zeppelin and its usage of Docker. First, there is the scenario where a client is malicious; second, there is the scenario where a worker is malicious.

In the first case, where the client is trying to compromise the integrity of the worker, Docker was actively selected to deter such attacks. Since Docker is an external dependency the end user is required to keep it up to date independently from Zeppelin, meaning that no responsibility can be assumed for security flaws in external software.

In the second case, when requesting that a third party run your code, there is always the possibility that the code is modified prior to running. Zeppelin is not exempt from this exploit. A worker could, for example, modify your code and report that everything is running as you requested, while the worker is not actually performing the task you requested. The aim for this could be to perform as little actual work as possible, in order to maximize the amount of work contracts a worker can take on at one time, for monetary gain. 
