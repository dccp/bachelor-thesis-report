\chapter{Discussion}
The result of the study is a protocol for a decentralized cloud computing platform where a free market is used to distribute work throughout the network. In its current state, the protocol is best suited to host web applications, but could easily be extended to more complex types of applications. The protocol itself has no single point of failure, or any external authority which might revoke access to it. However, the workers in the network can still be individually attacked, but it can be argued that workers have the motivation to mitigate such attacks since their payment is dependent on work performance.
The network achieves decentralization because
\begin{inparaenum}[\itshape a\upshape)]
\item the specification and reference implementation are both open source;
\item each end user retains a copy of the blockchain in which the smart contracts and data of the application are stored; and
\item each end user runs the application locally. 
\end{inparaenum}

In the introduction, three basic requirements for the network were listed. The requirements call for the network to be transparent, resilient and trustless. By virtue of the open and distributed data store of the blockchain, the network can be deemed to be transparent. Resilience is achieved on the data store level by the Ethereum network, and on the work execution level by incentives offered to workers. The inherent trustlessness in the blockchain and smart contracts allows parties to agree upon work and payment. Thus, we argue that these requirements have been met.

\section{Method discussion}
To alleviate further research within the field, and to allow future studies to build on the conducted thesis work, the methods will be briefly discussed. A central point is that the thesis work suffered from unnecessary overhead due to dependencies on unfinished software.

\subsection{Ethereum client dependencies}
At the inception of the study, three different Ethereum client implementations were widely used: the C++ based client cpp-ethereum; the Go-lang based client go-ethereum; and the Python based client pyethereum. All of the clients were at the time developed in parallel, stepping towards milestones implementing different aspects of the Ethereum specifications. The different clients were not always completely interchangeable, which was cumbersome while testing new client features on the different platforms. Since the stable releases were rapidly becoming outdated, the implementation was dependent on bleeding edge builds of the C++ and Go clients. As a result of this, large amounts of time was spent waiting for regression errors to be addressed in certain clients, and for cross-compatibility or workarounds between the two clients to support the development efforts. Thus, the dilemma was to either stay at a stable client version without necessary features -- or to stay on the potentially broken bleeding edge. This problem can be completely attributed to the fact that depending on unfinished pre-released software has detrimental effects on the expected productivity.

\subsection{Implementation environment}
The initial solution was to implement the reference implementation in a command line Python client, using HTTP-requests to access the JSON-RPC API provided by Ethereum. This solution was abandoned because the JSON-RPC API expects input in the form of the Ethereum ABI (Application Binary Interface), which means that the client would have to supply the binary format. Implementing the ABI would be out of scope and to time consuming for the study. Thus, the web3.js library, which implements the Etherereum JavaScript API, acting as a higher level bridge to the Ethereum client. Changing from Python to JavaScript resulted in also changing from a command line client to creating to creating a web application.

\section{Protocol discussion}
While the protocol addresses all three problems presented in \fullref{sec:intro:problem}, it does so on different abstraction levels for the different subproblems. The most thoroughly described and concrete part of the protocol is the part regarding distribution of work. This matter is described in a sufficiently detailed way to make it simple to implement.

The verification of performed work is described on a more abstract level, omitting various implementation details that could prove to be necessary in order to make the verification process run reliably and to minimize trust between nodes. The approach described should however provide a solid ground from which the verification process can be further elaborated.

Regarding monetary compensation, the problem description is quite short. This fact is reflected in the protocol. However, this does not mean that there is any significant information missing. In any sufficiently advanced smart contract system it should be trivial to retain value in a contract and to release said value to specific users if and only if certain conditions are met.

\section{Reference implementation discussion}
The reference implementation, Zeppelin, does not fulfill the whole protocol specification. One of the main factors behind this is that the Ethereum platform is still under heavy development. Throughout the study, it has been unreliably to test new features, often with many regression errors and breaking API changes. This makes it complicated to make any steady progress on many protocol features. Instead, focus was shifted to assure that the distribution of work issue was solved as well as possible.

Since the decentralized technology is emerging, demonstrations and proof of concepts are key tools to achieve user and developer participation. In that sense, Zeppelin is not an optimal proof of concept for the technology due to the fact that it still requires a regular backend. However, it should still be viewed as an accomplishment, because we show that both can, in fact, interoperate. This can be seen as the greatest virtue of Zeppelin -- it is truly a proof of concept.

\subsection{Whisper}
The private chat described in \fullref{sec:res:dependencies} was meant to be fulfilled by Whisper, the peer-to-peer anonymous messaging protocol running in parallel with the Ethereum network. Whisper was to be used in order to exchange information between a client and a worker, such as IP-addresses and ports. Since Whisper only requires a public key and a topic in order to initiate the communication channel, it can be used as private chat. However, the Whisper project has not yet been developed fully as of 13-May-2015. Initial tests using Whisper as private chat gave insufficient performance to be able to function as private chat. This resulted in the decision to work around Whisper, and instead store more information in the smart contracts. Due to this, some of the privacy and security measures mandated by private chat were sacrificed in order to get a working reference implementation.

Security is affected in the following way: in the reference implementation, all IP-addresses and ports are accessible via smart contracts for anyone with access to the blockchain. If an attacker has all IP-addresses for every node (both worker and client), it is trivial to DDoS the nodes in the network. This is particularly dangerous in since, at present, the network is very small. 

\subsection{Networking}
The Internet is a large complicated structure, a network of networks. Negotiating communication between hosts is seldom trivial, due to the way the Docker transfer module works, workers behind routers need to have one or several ports forwarded to be able to accept direct communication from a client. As all the test units used throughout the study were hosted on a Local Area Network (LAN), under a single private IP-address, this caused problems with Network Address Translation. In a centralized system this could be solved by using the centralized server as an intermediary, where both the client and worker initiates communication with the centralized server, creating a network tunnel allowing communication between the two. But since Zeppelin is designed to be decentralized this is not possible. The only viable solution is to have the client connect directly to the worker, and this requires an open port.

The initial solution to this problem was to use either UPnP or NAT-PMP for internal port mapping. This would, in theory, solve the problem. Unfortunately, due to time constraints and problems during the implementation this feature did not reach a working state. The only way to test UPnP and/or NAT-PMP is via a LAN behind a NAT-enabled router. Since all development and testing was conducted remotely from a network with public IP-addresses and no NAT-enabled router, there was no compelling way to ensure this functionality. Instead of continuing on the UPnP solution, it was decided that manual port forwarding was sufficient for the reference implementation.

In the future, this solution could be extended to become completely network environment agnostic.

\subsection{Docker and security}
The security that Docker offers is only on the host level. Thus, if a client is trying to compromise the integrity of a worker by instructing it to run malicious work, Docker will deter such attacks. Since Docker is an external dependency the end user is required to keep it up to date independently from Zeppelin, meaning that no responsibility can be assumed for security flaws in external software. Should the IP of a worker become known by external parties, it could by used to initiate DDoS attacks or other similar attacks against the specific worker. This is not something that can be handled by Zeppelin -- instead, an effort is made to work proactively by shielding all such identities behind public keys and private chat.
