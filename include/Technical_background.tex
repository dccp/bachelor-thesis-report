\chapter{Technical background}
In this chapter we shall provide a technical background of the concepts which the protocol depends on. In addition, origins and implementations of those concepts will be described and related to the protocol and reference implementation work. Of special interest is the cryptocurrency network Bitcoin and its data store called the blockchain. The specific dependencies of the reference implementation, Ethereum and Docker, are also described. A brief summary of computer networking concepts required for the understanding of the protocol and reference implementation is also given.

\section{Bitcoin and the blockchain}
Bitcoin sparked a revolution in digital currencies when the white paper was released in 2009. The innovation of the blockchain and its implications is of special interest. All technical details in this section are taken from the Bitcoin white paper \cite{btc}, unless noted otherwise.

\subsection{General idea}
The purpose of Bitcoin is to provide a financial system where participants can send and receive money without involvement of third parties. Traditionally, these third parties consist of a governmental institution controlling a currency, and one or more commercial banks that transfer money from the sender to the recipient. This is problematic because a third party can perform malicious actions and moreover exert complete control over the process. Bitcoin introduces a decentralized exchange of digital tokens, where no middleman is required, nor is any trust between sender and recipient required. The only requirement to use Bitcoin is to have a computer with Internet access. Bitcoin ownership is linked to cryptographic keys, thus, a cryptographic public key is somewhat similar to a bank account. The intrinsic value of Bitcoin is discussed in~\cite{buterin:2011}. We shall now briefly discuss the key points of the Bitcoin whitepaper which enables the network to function. Below, Bitcoin refers to the Bitcoin network, and BTC refers to the currency.

\subsection{Transactions}
Transactions in the Bitcoin network are made in the following way: If Alice has one BTC and wants to send it to Bob, she will create a transaction stating that she transfers one BTC to Bob. The transaction is signed using her cryptographic private key, and then broadcast to the network. An attacker cannot spend Alice's BTC because the transaction can only be signed by her private key.

\subsection{Blockchain}
Bitcoin is based around the innovation called the \emph{blockchain}\footnote{The gramatically correct ``block chain'' has not gained widespread popularity.}. Nodes in the Bitcoin network send and receive transactions to their peers in the network, transactions are then checked for validity and placed together in a block of transactions. To calculate the current state of the network, the whole graph of blocks must be traversed.

A new block is created approximately every 10 minutes, with all transactions that occurred since the last block creation bulked in it. Figure~\ref{blockchain} shows the chain of blocks. Each block contains its parent hash; a nonce that proves the validity of the block; and all the transactions in the block. Since any valid transaction is part of some block, and all valid blocks are chained together, the blockchain can be seen as a distributed ledger, and proof of the true state of the network. Once the block has been created, any subsequent changes to a block will invalidate the nonce, and all the children block.

\begin{figure}[h]
\centering
\begin{tikzpicture}[auto] 
       \node[draw=none,text width=3cm] (block1) {Block};
       \draw[draw=black] (block1.north west) rectangle +(4.1cm, -2.25cm);
       \node[rectangle,draw] (hash1) 
            [below right=0.75cm and 0.15cm of block1.west,anchor=west] {Prev hash};
       \node[rectangle,draw] (nonce1) [right=0.3cm of hash1,anchor=west] {Nonce};
       \node[rectangle,draw] (item11) [below=0.8cm of hash1.west, anchor=west] {Tx}; 
       \node[rectangle,draw] (item12) [right=0.3cm of item11] {Tx};
       \node[rectangle,draw,minimum height=1.3em] (item12) [right=0.3cm of item12] {...};
       
       \node[draw=none,text width=3cm] (block2) [right=2cm of block1] {Block};
       \draw[draw=black] (block2.north west) rectangle +(4.1cm, -2.25cm);
       \node[rectangle,draw] (hash2) 
            [below right=0.75cm and 0.15cm of block2.west,anchor=west] {Prev hash};
       \node[rectangle,draw] (nonce2) [right=0.3cm of hash2,anchor=west] {Nonce};
       \node[rectangle,draw] (item21) [below=0.8cm of hash2.west, anchor=west] {Tx}; 
       \node[rectangle,draw] (item22) [right=0.3cm of item21] {Tx};
       \node[rectangle,draw,minimum height=1.3em] (item22) [right=0.3cm of item22] {...};

    \node[draw=none] (start1) [left=1.3cm of hash1] {\dots};
    \coordinate[right=0.2cm of nonce1] (start2);
    \coordinate[right=0.2cm of nonce2] (start3);
    \node[draw=none] (end) [right=1.4cm of nonce2] {\dots};
    \path[-latex] (start1) edge (hash1);
    \path[-latex] (start2) edge (hash2);
    \path[-latex] (start3) edge (end);
\end{tikzpicture}
\caption{Visualisation of blocks in the blockchain}
\label{blockchain}
\end{figure}

\subsection{Proof-of-work}
As stated above, the nonce is used to validate the integrity of a block, but also acts as a way to show that a sufficient amount of CPU power has been consumed. Like the name suggests, it is mean to be a regulatory mechanism making it hard to falsify blocks, since it requires CPU power. This process is implemented by finding a certain hash value, and there is no way to know what the hash will be before the calculation is done, so the nonce of the block has to be randomly chosen until a low enough hash has been found. Specifically, this is done by calculating the hash of all the contents in the block with a function returning a hash value lower than a network-wide set value, which is determined by the current difficulty level of the network. The difficulty level is a mechanic used to control how long, on average, the nodes of the network must work before a block is found. Once every week the difficulty is adjusted, to match the computational power available in the network. This is tuned to ensure an average block rate of approximately one block every 10 minutes. 

\subsection{Verification}
The blockchain solves a fundamental problem of transferring value online, namely that data (for instance money) could be copied and sent to multiple recipients. Alice can spend the same BTC twice by signing two different transactions. However, only one of these transactions will be accepted into a block, after which the other transaction will be considered invalid, and thus not be accepted into any block. In the same way, an overspending transaction will also be considered invalid.

\subsection{Incitement}
In order for the network to fully function, peer members of the network must provide the verifying calculations for the integrity of the blockchain. Without incitement, it would be unbelievable that peers would share their computational power to the benefit of the network. In the Bitcoin network, whenever the proof-of-work for a block is found, the worker is provided a number of BTC. The current reward is 25 BTC, however this reward halves every four years. Incentivizing the verification process thus leads to a more secure and robust network.

\subsection{Weakness}
There is one particular weakness in the way the blockchain integrity behaves. By default, nodes accept the longest blockchain as the representation of the network state, and the longest blockchain is always the one that has the most raw computing power behind it. However, if an attacker has control of more than 50\% of the computing power in the network she can take control of the blockchain by introducing transactions on a tampered blockchain. If an attacker manages to modify a block in an illegal way, and computes enough subsequent proof-of-work to make this blockchain the longest, with the modified block in it, other nodes will also start working on that chain, since it is the longest and thus the true representation of the network state. The situation is in practice very unlikely, since massive computing power would be needed in order to overthrow the Bitcoin blockchain.

\section{Ethereum}
Following the advent of Bitcoin and the blockchain, a number of initiatives were started to explore and utilize the power of the blockchain within a distributed and decentralized application context. One example is Namecoin, which uses the blockchain to store domain names. As a result of each project aiming to solve one specific problem, segmentation in the cryptocurrency projects ensued, with lots of duplication of effort. The Ethereum project was started to unify the open source blockchain efforts and provide a general purpose blockchain protocol which allows running arbitrary code in the blockchain. This means that any type of features can be programmed onto this protocol. Code is packaged in something called smart contracts, and are executed on a virtual machine, the Ethereum Virtual Machine (EVM)~\cite{ethereum:white}. The Ethereum network is built on top of DEVP2P, a peer-to-peer network between all nodes running Ethereum-compatible software.

In the Ethereum network, the cryptocurrency rewarded for mining blocks is called Ether. Ether ownership is linked either to an Ethereum public key, or to a smart contract, and can be transferred between the two with transactions.

\subsection{Smart contracts}
\label{sec:tech:contracts}
Smart contracts are a way to move and control assets using code to set up and enforce arbitrary rules. Contracts can be defined in three programming languages seen below. All of these programming languages are Turing complete. The programming languages can be used in order to define contracts and are compiled to EVM byte code before they are incorporated into the blockchain.

\begin{itemize}
    \item Solidity (C- and JavaScript-like)
    \item Serpent (Python-like)
    \item LLL (Lisp-like)
\end{itemize}

Smart contracts are inserted into the blockchain by creating a transaction containing the EVM code. The resulting contract will receive a unique hexadecimal identifier that can be used for subsequent contract interactions. Such interactions would be typical object-oriented getting and setting values, and invoking methods. In addition, a contract can create other contracts on the Ethereum blockchain, much like how an object can initialize other objects in object-oriented programming.

\subsection{Halting problem}
The notion of a Turing complete language executing in a blockchain raises the halting problem. In a Turing complete language there is no way to know whether a particular program will halt or not. To ensure that each contract interaction does halt, every Ethereum virtual machine instruction has a price, which must be paid by the requesting party~\cite{ethereum:yellow}. Therefore it is possible to argue that the EVM is \emph{quasi}-Turing complete in practice.

\subsection{Whisper}
The messaging protocol Whisper is used to send anonymous messages over the Ethereum network. A trivial solution to create a message protocol for the network would be to store messages in the blockchain, however, this is infeasible because it would be too expensive to send messages. Whisper solves the problem for short- to medium lived messages. The origin node sends a Whisper message to each of its connected peers. Whenever a Whisper message is received, the process is repeated until the message time to live has expired. Before the inital broadcast of the Whisper message, a proof-of-work must be completed, in order to prevent flooding of the network.

\subsection{External Interfaces}
An Ethereum client (either local or remote) can be accessed by two APIs. The lower level API, the Ethereum generic JSON-RPC is a remote procedure call scheme suited for fine grained control of the host client~\cite{generic-json-rpc}. On the higher level, there exists a JavaScript API built top of the JSON-RPC API~\cite{javascript-api}. The JavaScript API is targeted at usage in web application frontends with a backend either completely or partially stored in the Ethereum blockchain, with a reference implementation called web3.js being actively developed.

For communication with the blockchain, the expected format is in binary. The Ethereum contract ABI (Application Binary Interface) specifies the binary format~\cite{ethereum-contract-abi}. For the end user, or developer, the ABI is abstracted away by higher level constructs, such as the JavaScript API, which handles the conversion from high level objects to binary data.

\subsection{Ethereum ecosystem}
To use the Ethereum network, a client connected to the Ethereum network is required. There are a number of different clients, and client environments, listed in Table~\ref{eth-clients}. Note that both command line and graphical clients are provided. The primary Ethereum client implementations are in Go and C++, with a peripheral Java implementation and a discontinued Python implementation. These clients serve as the interface to the Ethereum decentralized application platform and the Whisper anonymous message passing service.

Under the Ethereum project umbrella, a whole ecosystem for decentralized applications is developed. To deliver decentralized applications to end users, the preferred method is to build frontends in standard web technologies, such as JavaScript and HTML, which most end users and developers are familiar with. Since the identity of the user is linked to their Ethereum public key, users never need to sign up or create accounts in these decentralized applications, since their public key uniquely identifies them. The frontend interfaces with an Ethereum client to interact with the underlying network peers and the business logic stored in the smart contracts associated with the application. In Figure~\ref{fig:tech:stack}, the full application stack is listed.
From a development standpoint, this invites to rich client applications and thin servers, where in fact most web content can be served statically, since the application data and business logic is stored in the blockchain. Note the contrast to traditional web application architectures, where data and business logic is available only to and through the application server. With a decentralized application, the data and business logic is available and auditable by all users of the application.

% Ethereum application stack according to V. Buterin
% http://www.reddit.com/r/ethereum/comments/2p7i3w/is_this_the_ethereum_application_stack/
% Hitta annan k√§lla? 
% 0. Humans
% 1. Internet
% 2. DEVP2P (general-purpose P2P networking layer)
% 3. Ethereum | Whisper | Swarm
% 4. HTML/JS Dapp development environment (AlethZero)
% 5. Mist
% 6. Happy DAPPS!

\begin{table}[ht]
\centering
\caption{Ethereum client matrix}
\label{eth-clients}
\begin{tabular}{|l|l|l|l|l|}
\hline \textbf{Implementation} & Go & C++ & Java & Python \\ \hline
\textbf{GUI client} & Mist & AlethZero & studio & N/A \\ \hline 
\textbf{CLI client} & geth & eth & core & N/A \\ \hline
\end{tabular}
\end{table}

\begin{figure}[ht]
\centering
\begin{tikzpicture}[auto]
\tikzset{every node/.style={minimum width=5cm,minimum height=1.5cm}}
\node[rectangle,draw] (dapps) {Decentralized applications};
\node[rectangle,draw] (devenv) [below=0cm of dapps] {Mist/AlethZero};
\node[rectangle,draw,minimum width=2.5cm] (ethereum) [below=1.5cm of devenv.west, anchor=west] {Ethereum};
\node[rectangle,draw,minimum width=2.5cm] (whisper) [below=1.5cm of devenv.east, anchor=east] {Whisper};
\node[rectangle,draw] (devp2p) [below=1.5cm of ethereum.west, anchor=west] {DEVP2P};
\node[rectangle,draw] (internet) [below=0cm of devp2p] {\textit{Internet}};
\end{tikzpicture}
\caption{Ethereum Application Stack.}
\label{fig:tech:stack}
\end{figure}

\section{Docker}
Software today is generally quite complex. A website, for example, is most often much more than a simple HTML-document. To generate the HTML-document, there could be numerous programs and services running on the server side, \textit{e.g.} the web server, components encapsulating business logic, rule engine, database, document storage. To deploy all these services, on different platforms, would be time consuming and error prone. With Docker, such processes can be containerized, which allows the application to be run in a virtual-like manner on the Linux kernel, without the performance overhead of running a virtual machine \cite{docker-about}, simplifying the deployment and management.

\subsection{Virtualized containers}
Docker uses virtualization techniques to create isolated environments called containers which can be executed as if they were a runnable file. There are two distinct advantages for this. The first one is that since the containers are a full application packaged with its dependencies, it comes pre-compiled and is ready to run on any architecture that supports Docker (and is on the same architecture the application was compiled for). The other advantage is that a containerized application is isolated from both the system it is running on, as well as other containerized applications running on the system. If the code were to run directly on the host system, it would have been exposed to a number of exploits~\cite{korpela:2012}. Containerizing and virtualizing mitigates the immediate threat of such exploits.

\subsection{Security}
An important factor when volunteering to run arbitrary code on a private machine is security. The software could potentially corrupt the data on disks, or steal all the data. 
Docker containers are executed in a separate environment, a kernel namespace, from other containers and the host machine, meaning that it cannot know about or interact with the outside world~\cite{docker-security}. To communicate with the outside world, certain ports can be exposed on the container, and will be mapped to the host machine. Thus, network communication can only occur in an expected and controlled way. 

A containerized application can be run with restrictions on CPU and memory usage, to prevent memory leaks to propagate to the host system.

\subsection{Dockerfile}
Docker images are defined by a format called Dockerfile~\cite{docker-dockerfile}. The easiest, and the most common, method of building a Docker image is to use one of many provided base images, available directly from the leading distributors in the market such as Nginx, Ubuntu, MySQL and WordPress, to name a few. The image builder selects a fitting base image, adds the required configuration and data, and saves the resulting image under a tag in the local Docker repository. This image can then be exported and distributed for deployment wherever desired.

\section{Networking}
Communicating between devices over a local network is relatively simple, but for connections via the Internet, a device behind a gateway can not be directly reached by a remote device unless there is a path through the gateway mapped to it, in the form of a combination between the external IP address and a port number. This is done via a method called NAT~\cite{kurose:p349}. 

\subsection{NAT}
Network Address Translation is a method commonly used to map any device on an internal network to an external network like the Internet.~\cite{kurose:p349} It works by storing a port number together with the local IP address of the local device on the networks gateway device. When packets are received by the gateway with the combination external IP and NAT port they are modified and forwarded to the internal device.

\subsection{UPnP}
Universal Plug and Play, abbreviated UPnP, is a network protocol that allows connected devices to discover each others presence and establish a connection to each other on a network in order to share data, communicate and allow media services to work~\cite{kurose:p352}. UPnP port forwarding can be implemented in several ways, such as IGD-PCP and NAT-PMP.

\subsection{IGD-PCP}
Internet Gateway Device - Port Control Protocol, IGD-PCP, is a NAT Port Mapping Protocol which is supported by many routers. Many applications, such as Ethereum and Zeppelin, require the ability to send and receive data from the Internet. In cases where there is a NAT enabled router between the sender and recipient, NAT traversal must take place in order for communication to work~\cite{igd-pcp:rfc}. As seen in figure~\ref{fig:igd}, IGD-PCP enables a client computer behind a NAT-enabled router to find out it's external IP and then add and/or remove port mappings to the computer. 

\begin{figure}[H]
\centering
\begin{itemize}
    \item Learn the public (external) IP address
    \item Requesting for a new public IP address
    \item Enumerate existing port mappings
    \item Add and remove port mappings
    \item Assign lease times to mappings
\end{itemize}
\caption{Features enabled by Internet Gateway Device Protocol~\cite{igd-pcp:rfc}.}
\label{fig:igd}
\end{figure}

\subsection{NAT-PMP}
NAT-PMP was developed by Apple as an alternative to Internet Gateway Device Protocol. It is used as a network protocol for port forwarding without user interaction~\cite{nat-pmp:rfc}.