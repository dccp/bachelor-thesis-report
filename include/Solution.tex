\chapter{Solution}
Our solution consists of a general protocol, which fulfills the demands of the proposed network outlined in 1.2 Purpose and solves the underlying problem described in 1.3 Problem.
In addition to the protocol, a reference implementation has been developed and tested on a small scale network.

\section{General protocol}
The network connects clients, who pay to perform work, with workers, which are paid to perform work. In order for the network, and its cloud computing platform, to thrive, it relies on an open market where the supply of workers meets the demand of clients. Any person with a computer could register to become a worker and receive payment for the work they perform, and conversely, any person with the desire to execute arbitrary code can do so, provided they can pay for it. The high level flow of workers and clients within the network is shown in Figure~\ref{network-schema}.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[auto]
   \node[cloud, cloud puffs=15.7, cloud ignores aspect, minimum width=4cm, minimum height=2cm, draw, align=center] (butt) {Network}; 
   \node[ellipse,draw] (cli)  [left=of butt]        {Client}; 
   \node[ellipse,draw] (wkr1) [right=of butt]       {Worker}; 
   \node[ellipse,draw] (wkr2) [below right=of butt] {Worker}; 
   \node[ellipse,draw] (wkr3) [below left=of butt]  {Worker}; 
    \path[-latex] 
    (cli)   edge              node        {2} (butt)
    (wkr1)  edge              node [swap] {1} (butt)
    (wkr2)  edge [bend left]  node [swap] {1} (butt)
            edge [loop right, ->, >=latex] node {4} (wkr2)
    (wkr3)  edge              node        {1} (butt)
    (butt)  edge [bend left]  node        {5} (wkr2)
            edge              node        {3} (wkr2);
\end{tikzpicture}

\begin{enumerate}
\item Workers register to the network
\item Client sends work and payment to the network
\item Worker receives work
\item Worker performs work
\item Network confirms work and sends payment to worker
\end{enumerate}
\caption{Simplified network state diagram}
\label{network-schema}
\end{figure}

We propose that a blockchain with capability to store and execute code can be used to satisfy the requirements specified in 1.2 Purpose.

\subsection{Dependencies and assumptions}
We assume that there exists some external blockchain in/on which, the network will store its data and that it provides trustless arbitration between the involved parties. The term contract is used as a shorthand for smart contract, which we shall define to be a concept with at least the set of capabilities of smart contracts as described in the Ethereum white paper~\cite{ethereum:white}. \textbf{Lista dessa!} We also assume that two peers can communicate anonymously, given that each peer has access to the public key of the other peer. This will be referred to as private chat. Finally we also assume we have a way of packaging work so that it is easy for workers to perform and for clients to package.

Note that the protocol is platform agnostic, in spite of the assumptions made and the dependencies required.

\subsection{Communicating with the network}
Communication at the network level consists of actions which change the state of at least one contract in the blockchain. Contracts are used for
\begin{inparaenum}[\itshape a\upshape)]
\item storing data that must be persistent;
\item arbitration between worker and client; and
\item to hold monetary value in escrow.
\end{inparaenum}
Events triggering these actions bla bla bla...

\subsection{Direct communication between clients and workers}
For the communication between specific clients and workers, private chat is used. When transferring data from the client to the worker encrypted TCP/IP traffic is used. The hosted data provided by the worker is accessible through http/https (OBS: givet att det i dockern finns en webbserver som snurrar, vad händer om t.ex. porten är upptagen? Docker garanterar inte att en viss service startar på en viss port).

\subsection{Fundamental contract interactions}
The protocol consists of two contracts. WorkAgreement and  WorkerDispatcher.

WorkAgreement is the contract which deals with the interaction between the client and the worker. This contract holds the value paid by the client for the work to be done in escrow. When the worker has done the work described in this contract the value is released to the worker's account.

WorkerDispatcher is the main contract of the protocol. It provides a way for workers to register their interest to perform work, and saves them in a list. Clients can then use this contract to buy WorkAgreement contracts. This is done by calling the function $buyContract$ with desired parameters. The WorkerDispatcher creates a WorkAgreement if possible and returns the address of the contract.
\\TODO: UML figures

\subsection{Brokering the client-worker agreement}
When a client has received a WorkAgreement from the WorkerDispatcher the client initiates a comunication with the assigned worker through private chat. The client starts by sending the WorkAgreement contract address to the worker. The worker proceeds to check if it agrees the contract and that it is correct. When the verification is done the worker sends a message over private chat to the client with the IP and port for transferring the packaged work (explained in next section). When the transfer is done the worker starts to deploy the packaged work. When the work is ready to be accessed the worker sends a message to the client specifying the IP and port for http/https access.

\subsection{Docker-transfer in action!}
Docker magic! Hitta på namn för den abstrakta specen.

\subsection{Auditing/Verification}
In order to know that a worker is performing a given work, other workers are assigned as verifiers. These verifiers are given a time frame in which they are required to report checked parameters of the given worker to the WorkAgreement contract. The most basic check that could be done is simply for the verifier to check that the worker is providing the given work through the IP and port that it has communicated. This does however only check uptime of the given worker not that the work has been correctly performed. More rigid testing could be done by the verifiers by making more specific request to the worker, but since the verifiers do not really know anything about the work to be done, the client will have to provide this specific request information.

\subsection{Payment arbitration}
When a WorkAgreement is created it must also be provided with an appropriate amount of payment for the given work. The value of this payment is then held in escrow by the contract until some specified conditions in the contract has been met. These conditions consists of verifications that the verifiers have performed and checks that the worker has performed for the given amount of time. When all conditions are met the worker can make a special method call to the WorkAgreement and the contract will make a payout the the worker.

\subsection{Security concerns}
The protocol itself can be seen as secure in most aspects as it mostly runs on top of a blockchain. Security concerns can instead be found in that individual workers can be attacked. Workers provide their services through regular http/https connections and is therefore vulnerable to DDos-attacks and MITM-attacks etc. just as regular service providers are. The protocol does not take this into account and thus only reward workers that have successfully provided results. However if the protocol is implemented correctly only the client and verifiers can know the IP-address of the worker if the client doesn't share it.

\subsection{Environmental impact}
Not much research has been done in the environmental impact of decentralized networks. It is very hard to forese  
Hähähähä \cite{cook}.

\section{Reference implementation: Zeppelin}
The reference implementation, called Zeppelin,\footnote{Because a Zeppelin navigates above the clouds with grace.} is a web application for end users, which is dependent on the Ethereum network. For computational integrity, the client constructs a Docker image which is sent to the worker. The implementation is built around the concept of a thin server, and a fat client. Of note is the fact that there are two backends with which the frontend communicates; the webserver, acting as the \textit{traditional} backend; and the smart contract interaction through Ethereum, acting as the secondary backend for all blockchain-based interactions. Zeppelin is not a complete implementation of the protocol described above. Rather it only deals with the aspect of distribution of work. However it is possible to build upon Zeppelin to implement the remaining features of the protocol.

\subsection{System design}
The system design is characterized by high modularity, allowing for reuse or reimplementation of most modules within the solution stack. In Figure~\ref{zep-stack}, the component diagram for the full stack is shown. The only strict dependency is on Docker, all other components can be substituted.

\textbf{Zeppelin frontend.} For the simplicity of the end user, all interactions are made in a web interface, in the form of a client application, implemented in React. The frontend interacts with two backends to display data.

\textbf{Zeppelin backend.} This module acts as the \textit{traditional} backend, serving the static client web application and acting as a RESTful server for user interactions with Docker. The REST API is specified in \textbf{Figure XX}.

\textbf{Docker transfer.} Client and server for sending and receiving gzipped Docker images and running the containers.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[auto]
\tikzset{every node/.style={minimum width=5cm,minimum height=1cm}}
\node[rectangle,draw] (frontend) {Frontend};
\node[rectangle,draw] (backend) [below right=2cm,-4cm of frontend] {Backend};
\node[rectangle,draw] (xfer) [below=1cm of backend] {Docker transfer};
\node[rectangle,draw] (docker) [below=1cm of xfer] {Docker daemon};
\node[rectangle,draw] (web3) [below left=2cm,-4cm of frontend] {web3.js};
\node[rectangle,draw] (ethcl) [below=1cm of web3] {Ethereum client};
\node[cylinder, shape border rotate=90, draw, height=0.5] (ethblk) [below=1cm of ethcl] {Ethereum blockchain};

\path[-latex] 
    (frontend)  edge [bend left]  node    {REST}              (backend)
    (backend)   edge    node    {JS import lol}     (xfer)
    (xfer)      edge    node    {Native}    (docker)
    (frontend)  edge [bend right] node [swap] {JS import lol} (web3)
    (web3)      edge    node  [swap]  {JSON-RPC}          (ethcl)
    (ethcl)     edge    node  [swap]  {DEVP2P}            (ethblk);
\end{tikzpicture}
\caption{Zeppelin full stack}
\label{zep-stack}
\end{figure}

\subsection{Contracts}
The Ethereum contract implementation is realized in the C- and JavaScript-like Ethereum-specific language Solidity.
\begin{lstlisting}[caption={WorkAgreement contract}, label={lst:workagreement}]
contract WorkAgreement {
    address client;
    address worker;
    function WorkAgreement(address _client, address _worker, uint _price, uint length) {
        end = length;
    }
    function addTester(address tester) {
        testers[tester] = true;
    }
}
\end{lstlisting}

\subsection{Security}
The Zeppelin network is resistant to DDoS-attacks, since it is decentralized. Since each user of the network deploys Zeppelin locally, and Ethereum is impervious to DDoS-attacks, service uptime is guaranteed.

\subsection{Deployment}
How do I deploy the internets?!?!

% Skriv om problem vi löser, typ DDoS etc
